Here are detailed notes on the "decrease and conquer" strategies based on the content from the PDFs you uploaded:

### Decrease and Conquer Overview:
- **Decrease and Conquer** is a problem-solving strategy that involves reducing the problem's size with each step. The solution to a smaller instance is extended to solve the larger problem.
- The approach can be implemented **recursively** (top-down) or **iteratively** (bottom-up).

### Three Variants of Decrease and Conquer:
1. **Decrease by a Constant**:
   - The problem size is reduced by a fixed amount at each step (e.g., 1).
   - Examples: **Insertion Sort** and **Topological Sort**.
   
2. **Decrease by a Constant Factor**:
   - The problem size is reduced by a constant factor (e.g., halved).
   - Example: **Fake Coin Problem**.

3. **Decrease by a Variable Size**:
   - The problem size is reduced by a variable amount at each step.
   - Example: **Greatest Common Divisor (GCD) Algorithm**.

---

### Key Examples:

1. **Decrease by a Constant: Insertion Sort**:
   - Assume the list of size \(n-1\) is sorted, and the \(n\)th element is inserted into the correct position.
   - The recursive version works, but the **iterative** method is often preferred for efficiency.
   - Worst-case efficiency is \( \Theta(n^2) \), but it performs well on partially sorted data.
   - [Source for Insertion Sort Example, Lecture 6+7c, page 1](6)

2. **Decrease by a Constant: Topological Sort**:
   - In a **Directed Acyclic Graph (DAG)**, vertices are sorted so that for every directed edge \( u \to v \), \( u \) appears before \( v \) in the ordering.
   - This can be solved with **Depth First Search (DFS)**.
   - Application examples include scheduling tasks in a project or ordering courses based on prerequisites.
   - [Source for Topological Sort Example, Lecture 6+7c, page 7](6)

3. **Decrease by a Constant Factor: Fake Coin Problem**:
   - In this problem, among \( n \) coins, one is fake and weighs less.
   - The strategy involves dividing the coins into two equal piles (or almost equal, leaving one coin out if the number is odd).
   - Weigh the two piles. If one is lighter, it contains the fake coin; otherwise, the extra coin is fake.
   - This approach runs in \( \Theta(\log n) \) time.
   - There is an alternative version where coins are divided into three piles, improving efficiency by a factor of 1.6 (reducing time to \( \Theta(\log_3 n) \)).
   - [Source for Fake Coin Problem Example, Lecture 5c, pages 28-30](7)

4. **Generating Permutations (Decrease by 1)**:
   - Permutations are generated by considering permutations of a smaller list and inserting the \( n \)-th element in every possible position.
   - **Steinhaus-Johnson-Trotter Algorithm** is an alternative, where permutations are generated without creating smaller sub-problems by keeping track of the next permutation using arrows.
   - [Source for Permutations Example, Lecture 6+7c, page 10](6)

5. **Greatest Common Divisor (GCD) Algorithm (Variable Size Decrease)**:
   - Finds the GCD of two integers using the relation \( gcd(a, b) = gcd(b, a \mod b) \).
   - The size of the problem decreases variably based on the remainder from the division.
   - Example: \( gcd(60, 24) = gcd(24, 12) = gcd(12, 0) = 12 \).
   - [Source for GCD Example, Lecture 6+7c, page 26](6)

---

These notes capture the essential concepts and key examples of "decrease and conquer" strategies from your PDFs. If you need more details on specific parts, feel free to ask!
