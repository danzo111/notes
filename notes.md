Decrease and Conquer Overview:
Decrease and Conquer is a problem-solving strategy that involves reducing the problem's size with each step. The solution to a smaller instance is extended to solve the larger problem.
The approach can be implemented recursively (top-down) or iteratively (bottom-up).
Three Variants of Decrease and Conquer:
Decrease by a Constant:

The problem size is reduced by a fixed amount at each step (e.g., 1).
Examples: Insertion Sort and Topological Sort.
Decrease by a Constant Factor:

The problem size is reduced by a constant factor (e.g., halved).
Example: Fake Coin Problem.
Decrease by a Variable Size:

The problem size is reduced by a variable amount at each step.
Example: Greatest Common Divisor (GCD) Algorithm.
Key Examples:
Decrease by a Constant: Insertion Sort:

Assume the list of size 
𝑛
−
1
n−1 is sorted, and the 
𝑛
nth element is inserted into the correct position.
The recursive version works, but the iterative method is often preferred for efficiency.
Worst-case efficiency is 
Θ
(
𝑛
2
)
Θ(n 
2
 ), but it performs well on partially sorted data.
Decrease by a Constant: Topological Sort:

In a Directed Acyclic Graph (DAG), vertices are sorted so that for every directed edge 
𝑢
→
𝑣
u→v, 
𝑢
u appears before 
𝑣
v in the ordering.
This can be solved with Depth First Search (DFS).
Application examples include scheduling tasks in a project or ordering courses based on prerequisites.
Decrease by a Constant Factor: Fake Coin Problem:

In this problem, among 
𝑛
n coins, one is fake and weighs less.
The strategy involves dividing the coins into two equal piles (or almost equal, leaving one coin out if the number is odd).
Weigh the two piles. If one is lighter, it contains the fake coin; otherwise, the extra coin is fake.
This approach runs in 
Θ
(
log
⁡
𝑛
)
Θ(logn) time.
There is an alternative version where coins are divided into three piles, improving efficiency by a factor of 1.6 (reducing time to 
Θ
(
log
⁡
3
𝑛
)
Θ(log 
3
​
 n)).
Generating Permutations (Decrease by 1):

Permutations are generated by considering permutations of a smaller list and inserting the 
𝑛
n-th element in every possible position.
Steinhaus-Johnson-Trotter Algorithm is an alternative, where permutations are generated without creating smaller sub-problems by keeping track of the next permutation using arrows.
Greatest Common Divisor (GCD) Algorithm (Variable Size Decrease):

Finds the GCD of two integers using the relation 
𝑔
𝑐
𝑑
(
𝑎
,
𝑏
)
=
𝑔
𝑐
𝑑
(
𝑏
,
𝑎
m
o
d
 
 
𝑏
)
gcd(a,b)=gcd(b,amodb).
The size of the problem decreases variably based on the remainder from the division.
Example: 
𝑔
𝑐
𝑑
(
60
,
24
)
=
𝑔
𝑐
𝑑
(
24
,
12
)
=
𝑔
𝑐
𝑑
(
12
,
0
)
=
12
gcd(60,24)=gcd(24,12)=gcd(12,0)=12.
